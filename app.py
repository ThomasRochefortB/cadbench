import os
import subprocess
import tempfile
from pathlib import Path
import shutil

from flask import Flask, jsonify, request, send_from_directory
from flask_cors import CORS
from dotenv import load_dotenv

try:
    import openai
except ImportError:
    openai = None  # Optional: allows running without openai installed

# --- Configuration -----------------------------------------------------------------------------
FREECAD_DOCKER_IMAGE = "linuxserver/freecad:0.20.2"  # Docker image for FreeCAD

app = Flask(__name__, static_url_path="", static_folder="static")
CORS(app)

# If using OpenAI, make sure the environment variable is set. You can load a .env file as needed
load_dotenv()
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
if openai and OPENAI_API_KEY:
    openai.api_key = OPENAI_API_KEY

# Prompt template used to ask the LLM to generate FreeCAD python code
PROMPT_TEMPLATE = """
You are an expert FreeCAD developer. Write a standalone FreeCAD Python script that fulfils the following user request.
The script MUST:
1. Import FreeCAD and needed modules.
2. Build the geometry corresponding to the user description.
3. Save the resulting document to a file called /data/output.FCStd.
Do NOT add explanations or comments outside the python code. Only output valid python code.
User request: {user_prompt}
"""

# Helper ----------------------------------------------------------------------------

def generate_code_with_llm(user_prompt: str) -> str:
    """Return python code generated by the LLM. If no LLM configured, return a stub."""
    if openai and OPENAI_API_KEY:
        client = openai.OpenAI(api_key=OPENAI_API_KEY)
        response = client.chat.completions.create(
            model="gpt-4o-mini",  # Change to desired model
            messages=[
                {"role": "system", "content": "You generate FreeCAD scripts."},
                {"role": "user", "content": PROMPT_TEMPLATE.format(user_prompt=user_prompt)},
            ],
        )
        return response.choices[0].message.content.strip()
    # Fallback stub if OpenAI not available
    return (
        "import FreeCAD, Part, Sketcher\\n"
        "doc = FreeCAD.newDocument()\\n"
        "box = Part.makeBox(10, 10, 10)\\n"
        "Part.show(box)\\n"
        "doc.recompute()\\n"
        "doc.saveAs('/data/output.FCStd')\\n"  # Changed to absolute path /data/output.FCStd
    )


def try_execute_freecad_script(script: str) -> tuple[Path | None, str | None]:
    """Attempt to run FreeCAD in headless mode using Docker to generate a CAD file.
    Returns a tuple of (path to generated file or None if execution failed, error information)."""
    # Variables to track if we encountered an error
    last_error = None
    error_info = None
    
    try:
        # Check if Docker is installed and accessible
        subprocess.run(["docker", "--version"], check=True, capture_output=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        print("Docker command not found or Docker is not running. Skipping FreeCAD execution.")
        return None, "Docker command not found or Docker is not running"

    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir_path = Path(tmpdir)
        script_path = tmpdir_path / "gen.py"
        script_path.write_text(script)

        # Docker command to run FreeCAD
        # Mounts the temporary directory to /data inside the container
        # Executes freecadcmd on /data/gen.py
        # Ensures the container is removed after execution (--rm)
        # Runs as current user to avoid permission issues with created files
        docker_command = [
            "docker", "run",
            "--rm",
            "-e", f"PUID={os.getuid()}",
            "-e", f"PGID={os.getgid()}",
            "-v", f"{str(tmpdir_path.resolve())}:/data",
            FREECAD_DOCKER_IMAGE,
            "freecadcmd", "/data/gen.py"
        ]

        try:
            print(f"Executing FreeCAD script in Docker: {' '.join(docker_command)}")
            process = subprocess.run(docker_command, check=False, capture_output=True, text=True, timeout=60) # Added timeout
            
            # Capture any error messages for returning to the frontend
            error_lines = []
            if process.stderr:
                for line in process.stderr.splitlines():
                    if any(err in line for err in ["Exception", "Error:", "has no attribute", "Traceback", "FileNotFoundError"]):
                        error_lines.append(line.strip())
                
                if error_lines:
                    error_info = "\n".join(error_lines)
                    last_error = "FreeCAD encountered errors during execution"
            
            # --- Log subprocess output to ease debugging ---
            print("FreeCAD Docker execution stdout:\n" + process.stdout)

            # Always show stderr to catch warnings/errors even when exit code is 0 (FreeCAD sometimes
            # swallows Python exceptions and still exits successfully)
            if process.stderr:
                print("FreeCAD Docker execution stderr:\n" + process.stderr)

            if process.returncode != 0:
                print(f"FreeCAD Docker execution failed with return code {process.returncode}")

        except subprocess.TimeoutExpired:
            print("FreeCAD Docker execution timed out.")
            return None, "FreeCAD Docker execution timed out"
        except Exception as e:
            print(f"An error occurred while trying to run FreeCAD in Docker: {e}")
            return None, f"Error running FreeCAD in Docker: {str(e)}"

        out_file = tmpdir_path / "output.FCStd"
        if out_file.exists() and out_file.stat().st_size > 0: # Check if file is not empty
            # Export STL for web viewing
            stl_out_file = tmpdir_path / "output.stl"
            # Run FreeCAD again to convert FCStd to STL
            stl_script = (
                f"import FreeCAD\n"
                f"doc = FreeCAD.open('/data/output.FCStd')\n"
                f"import Mesh\n"
                f"Mesh.export(doc.Objects, '/data/output.stl')\n"
            )
            stl_script_path = tmpdir_path / "export_stl.py"
            stl_script_path.write_text(stl_script)
            
            # Run a second Docker command to export the STL
            try:
                stl_docker_command = [
                    "docker", "run",
                    "--rm",
                    "-e", f"PUID={os.getuid()}",
                    "-e", f"PGID={os.getgid()}",
                    "-v", f"{str(tmpdir_path.resolve())}:/data",
                    FREECAD_DOCKER_IMAGE,
                    "freecadcmd", "/data/export_stl.py"
                ]
                subprocess.run(stl_docker_command, check=False, capture_output=True, text=True, timeout=30)
                if stl_out_file.exists() and stl_out_file.stat().st_size > 0:
                    stl_final_path = Path("static") / "output.stl"
                    stl_final_path.unlink(missing_ok=True)
                    shutil.move(str(stl_out_file), str(stl_final_path))
                    print(f"Successfully moved STL to {stl_final_path}")
                    stl_path = stl_final_path
            except Exception as e:
                print(f"Error exporting STL: {e}")
            
            # Continue with original FCStd file
            final_path = Path("static") / "output.FCStd"
            final_path.parent.mkdir(parents=True, exist_ok=True) # Ensure parent directory exists
            try:
                # Ensure the static directory and output.FCStd are writable
                # This might be an issue if Docker creates files as root
                # The --user flag in docker run should mitigate this
                final_path.unlink(missing_ok=True) # Remove if exists to avoid permission errors on replace
                shutil.move(str(out_file), str(final_path))
                print(f"Successfully moved {out_file} to {final_path}")
                return final_path, error_info
            except Exception as e:
                print(f"Error moving FreeCAD output file: {e}")
                # If moving fails, copy as a fallback, then try to delete original
                try:
                    shutil.copy(str(out_file), str(final_path))
                    print(f"Successfully copied {out_file} to {final_path} (fallback).")
                    out_file.unlink(missing_ok=True)
                    return final_path, error_info
                except Exception as e_copy:
                    print(f"Error copying FreeCAD output file (fallback): {e_copy}")
                    return None, f"Error copying FreeCAD output file: {str(e_copy)}"
        else:
            # Provide extra diagnostics when the expected result is missing so users can debug issues
            print(f"Output file {out_file} not found or is empty after FreeCAD execution.")

            # List the contents of the working directory to confirm what was produced
            try:
                print("Directory listing of temp folder after FreeCAD run:")
                for p in tmpdir_path.iterdir():
                    try:
                        print(f"  {p.name} (size: {p.stat().st_size} bytes)")
                    except Exception:
                        print(f"  {p.name} (unable to stat)")
            except Exception as e_ls:
                print(f"Unable to list temp directory for diagnostics: {e_ls}")

            if process.returncode == 0:
                print("FreeCAD process exited cleanly, but the expected output.FCStd file was not created by the script.")
            else:
                print(f"FreeCAD process exited with code {process.returncode}.")

            print("Script content was:\n", script)

    return None, error_info

# Routes -----------------------------------------------------------------------------

@app.route("/api/generate", methods=["POST"])
def generate():
    data = request.get_json(force=True)
    user_prompt = data.get("prompt", "").strip()
    if not user_prompt:
        return jsonify({"error": "Prompt is required"}), 400

    script = generate_code_with_llm(user_prompt)
    # Remove any markdown code fences that might be included in the script
    script = script.strip()
    if script.startswith("```") and "```" in script[3:]:
        # This is a markdown code block - extract just the code
        first_line_end = script.find("\n")
        script = script[first_line_end+1:]
        # Find the closing fence
        if "```" in script:
            script = script[:script.rindex("```")]
    
    # Replace doc.save() with doc.saveAs() in the script (saveAs is required for first-time save)
    script = script.replace("doc.save(", "doc.saveAs(")

    # In a headless docker environment FreeCADGui is unavailable; strip any imports that the model may have added
    if "FreeCADGui" in script:
        cleaned_lines = []
        for line in script.splitlines():
            if "FreeCADGui" in line:
                # Comment out the line so that line numbers stay unchanged (useful for tracebacks)
                cleaned_lines.append(f"# [removed] {line}")
            else:
                cleaned_lines.append(line)
        script = "\n".join(cleaned_lines)

    doc_path, error_info = try_execute_freecad_script(script)

    # Build response with URLs instead of filesystem paths
    response = {
        "script": script,
    }
    
    # Add FCStd file URL if available
    if doc_path:
        # Convert filesystem path to URL path
        fcstd_url = "/output.FCStd"
        response["fcstd_url"] = fcstd_url
    
    # Add error information if we have it
    stderr_output = error_info or ""
    if not doc_path:
        if stderr_output and "has no attribute" in stderr_output:
            response["error"] = "The LLM generated code with an invalid FreeCAD function"
        elif stderr_output and "Exception" in stderr_output:
            response["error"] = "The FreeCAD script had execution errors"
        else:
            response["error"] = "FreeCAD script failed to generate a model"
        
        if error_info:
            response["error_details"] = error_info
    
    # Check if we successfully created an STL file and add its URL
    stl_path = Path("static") / "output.stl"
    if stl_path.exists() and stl_path.stat().st_size > 0:
        stl_url = "/output.stl"
        response["stl_url"] = stl_url
    
    return jsonify(response)


@app.route("/")
def serve_index():
    return send_from_directory(app.static_folder, "index.html")


if __name__ == "__main__":
    app.run(debug=True, port=8000) 