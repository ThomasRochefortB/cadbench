import os
import subprocess
import tempfile
from pathlib import Path
import shutil

from flask import Flask, jsonify, request, send_from_directory
from flask_cors import CORS
from dotenv import load_dotenv
from prompts import ENHANCED_PROMPT_TEMPLATE

try:
    import litellm
except ImportError:
    litellm = None  # Allows running without litellm installed

# --- Configuration -----------------------------------------------------------------------------
FREECAD_DOCKER_IMAGE = "linuxserver/freecad:0.20.2"  # Docker image for FreeCAD

# Dictionary mapping model IDs to their display names
MODEL_DISPLAY_NAMES = {
    "openai/gpt-4o": "GPT-4o",
    "openai/gpt-4o-mini": "GPT-4o-mini",
    "openai/gpt-4.1": "GPT-4.1",
    "openai/o1": "o1",
    "openai/o3": "o3",
    "openai/o4-mini": "o4-mini",
    "anthropic/claude-3-7-sonnet-latest": "Claude 3.7 Sonnet",
    "anthropic/claude-3-5-haiku-latest": "Claude 3.5 Haiku",
    "anthropic/claude-3-5-sonnet-latest": "Claude 3.5 Sonnet v2",
    "anthropic/claude-3-5-sonnet-20240620": "Claude 3.5 Sonnet",
    "anthropic/claude-3-opus-latest": "Claude 3 Opus",
    "anthropic/claude-3-sonnet-20240229": "Claude 3 Sonnet",
    "vertex_ai/gemini-2.5-pro": "Gemini 2.5 Pro",
    "vertex_ai/gemini-2.5-flash": "Gemini 2.5 Flash",
}

app = Flask(__name__, static_url_path="", static_folder="static")
CORS(app)

# If using OpenAI, make sure the environment variable is set. You can load a .env file as needed
load_dotenv()

# List of available models
AVAILABLE_MODELS = list(MODEL_DISPLAY_NAMES.keys())

# Helper ----------------------------------------------------------------------------

def generate_code_with_llm(user_prompt: str, model_name: str) -> str:
    """Return python code generated by the LLM using LiteLLM."""
    if litellm and model_name in AVAILABLE_MODELS:
        try:
         
            response = litellm.completion(
                model=model_name,
                messages=[
                    {"role": "user", "content": ENHANCED_PROMPT_TEMPLATE.format(user_prompt=user_prompt)},
                ],
            )
            return response.choices[0].message.content.strip()
        except Exception as e:
            import traceback
            print(f"Error using LiteLLM with model {model_name}: {e}")
            print("Full traceback:")
            traceback.print_exc()
            raise RuntimeError(f"Error generating code with {model_name}: {str(e)}")
    
    # Raise an exception if LiteLLM is not available or model is not supported
    if not litellm:
        raise RuntimeError("LiteLLM is not installed or not available")
    else:
        raise RuntimeError(f"Model '{model_name}' is not supported. Available models: {', '.join(AVAILABLE_MODELS)}")


def try_execute_freecad_script(script: str, file_suffix: str = "") -> tuple[Path | None, str | None]:
    """Attempt to run FreeCAD in headless mode using Docker to generate a CAD file.
    Returns a tuple of (path to generated file or None if execution failed, error information)."""
    # Variables to track if we encountered an error
    last_error = None
    error_info = None
    
    try:
        # Check if Docker is installed and accessible
        subprocess.run(["docker", "--version"], check=True, capture_output=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        print("Docker command not found or Docker is not running. Skipping FreeCAD execution.")
        return None, "Docker command not found or Docker is not running"

    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir_path = Path(tmpdir)
        script_path = tmpdir_path / "gen.py"
        script_path.write_text(script)

        # Docker command to run FreeCAD
        # Mounts the temporary directory to /data inside the container
        # Executes freecadcmd on /data/gen.py
        # Ensures the container is removed after execution (--rm)
        # Runs as current user to avoid permission issues with created files
        docker_command = [
            "docker", "run",
            "--rm",
            "-e", f"PUID={os.getuid()}",
            "-e", f"PGID={os.getgid()}",
            "-v", f"{str(tmpdir_path.resolve())}:/data",
            FREECAD_DOCKER_IMAGE,
            "freecadcmd", "/data/gen.py"
        ]

        try:
            print(f"Executing FreeCAD script in Docker: {' '.join(docker_command)}")
            process = subprocess.run(docker_command, check=False, capture_output=True, text=True, timeout=60) # Added timeout
            
            # Capture any error messages for returning to the frontend
            error_lines = []
            if process.stderr:
                for line in process.stderr.splitlines():
                    if any(err in line for err in ["Exception", "Error:", "has no attribute", "Traceback", "FileNotFoundError"]):
                        error_lines.append(line.strip())
                
                if error_lines:
                    error_info = "\n".join(error_lines)
                    last_error = "FreeCAD encountered errors during execution"
            
            # --- Log subprocess output to ease debugging ---
            print("FreeCAD Docker execution stdout:\n" + process.stdout)

            # Always show stderr to catch warnings/errors even when exit code is 0 (FreeCAD sometimes
            # swallows Python exceptions and still exits successfully)
            if process.stderr:
                print("FreeCAD Docker execution stderr:\n" + process.stderr)

            if process.returncode != 0:
                print(f"FreeCAD Docker execution failed with return code {process.returncode}")

        except subprocess.TimeoutExpired:
            print("FreeCAD Docker execution timed out.")
            return None, "FreeCAD Docker execution timed out"
        except Exception as e:
            print(f"An error occurred while trying to run FreeCAD in Docker: {e}")
            return None, f"Error running FreeCAD in Docker: {str(e)}"

        # Check for model-specific output file first
        out_file = tmpdir_path / f"output{file_suffix}.FCStd"
        
        # If model-specific file not found, check for the generic output.FCStd
        if not out_file.exists() or out_file.stat().st_size == 0:
            generic_out_file = tmpdir_path / "output.FCStd"
            if generic_out_file.exists() and generic_out_file.stat().st_size > 0:
                print(f"Model-specific file not found, but generic output.FCStd exists. Using that instead.")
                # Rename the generic file to the model-specific name for further processing
                shutil.copy(generic_out_file, out_file)
        
        if out_file.exists() and out_file.stat().st_size > 0: # Check if file is not empty
            # Export STL for web viewing
            stl_out_file = tmpdir_path / f"output{file_suffix}.stl"
            # Run FreeCAD again to convert FCStd to STL
            stl_script = (
                f"import FreeCAD\n"
                f"doc = FreeCAD.open('/data/output{file_suffix}.FCStd')\n"
                f"import Mesh\n"
                f"Mesh.export(doc.Objects, '/data/output{file_suffix}.stl')\n"
            )
            stl_script_path = tmpdir_path / "export_stl.py"
            stl_script_path.write_text(stl_script)
            
            # Run a second Docker command to export the STL
            try:
                stl_docker_command = [
                    "docker", "run",
                    "--rm",
                    "-e", f"PUID={os.getuid()}",
                    "-e", f"PGID={os.getgid()}",
                    "-v", f"{str(tmpdir_path.resolve())}:/data",
                    FREECAD_DOCKER_IMAGE,
                    "freecadcmd", "/data/export_stl.py"
                ]
                subprocess.run(stl_docker_command, check=False, capture_output=True, text=True, timeout=30)
                if stl_out_file.exists() and stl_out_file.stat().st_size > 0:
                    stl_final_path = Path("static") / f"output{file_suffix}.stl"
                    stl_final_path.unlink(missing_ok=True)
                    shutil.move(str(stl_out_file), str(stl_final_path))
                    print(f"Successfully moved STL to {stl_final_path}")
                    stl_path = stl_final_path
            except Exception as e:
                print(f"Error exporting STL: {e}")
            
            # Continue with original FCStd file
            final_path = Path("static") / f"output{file_suffix}.FCStd"
            final_path.parent.mkdir(parents=True, exist_ok=True) # Ensure parent directory exists
            try:
                # Ensure the static directory and output.FCStd are writable
                # This might be an issue if Docker creates files as root
                # The --user flag in docker run should mitigate this
                final_path.unlink(missing_ok=True) # Remove if exists to avoid permission errors on replace
                shutil.move(str(out_file), str(final_path))
                print(f"Successfully moved {out_file} to {final_path}")
                return final_path, error_info
            except Exception as e:
                print(f"Error moving FreeCAD output file: {e}")
                # If moving fails, copy as a fallback, then try to delete original
                try:
                    shutil.copy(str(out_file), str(final_path))
                    print(f"Successfully copied {out_file} to {final_path} (fallback).")
                    out_file.unlink(missing_ok=True)
                    return final_path, error_info
                except Exception as e_copy:
                    print(f"Error copying FreeCAD output file (fallback): {e_copy}")
                    return None, f"Error copying FreeCAD output file: {str(e_copy)}"
        else:
            # Provide extra diagnostics when the expected result is missing so users can debug issues
            print(f"Output file {out_file} not found or is empty after FreeCAD execution.")

            # List the contents of the working directory to confirm what was produced
            try:
                print("Directory listing of temp folder after FreeCAD run:")
                for p in tmpdir_path.iterdir():
                    try:
                        print(f"  {p.name} (size: {p.stat().st_size} bytes)")
                    except Exception:
                        print(f"  {p.name} (unable to stat)")
            except Exception as e_ls:
                print(f"Unable to list temp directory for diagnostics: {e_ls}")

            if process.returncode == 0:
                print("FreeCAD process exited cleanly, but the expected output.FCStd file was not created by the script.")
            else:
                print(f"FreeCAD process exited with code {process.returncode}.")

            print("Script content was:\n", script)

    return None, error_info

# Routes -----------------------------------------------------------------------------

@app.route("/api/generate", methods=["POST"])
def generate():
    data = request.get_json(force=True)
    user_prompt = data.get("prompt", "").strip()
    if not user_prompt:
        return jsonify({"error": "Prompt is required"}), 400

    model1 = data.get("model1", "openai/gpt-4o-mini")
    model2 = data.get("model2", "openai/gpt-4o-mini")
    
    # Validate models
    if model1 not in AVAILABLE_MODELS:
        model1 = "openai/gpt-4o-mini"  # Default fallback
    if model2 not in AVAILABLE_MODELS:
        model2 = "openai/gpt-4o-mini"  # Default fallback
    
    # Generate scripts from both models
    results = []
    
    for i, model_name in enumerate([model1, model2]):
        script_file_suffix = f"_model{i+1}"
        model_result = {"model": model_name}
        
        try:
            # Generate script
            script = generate_code_with_llm(user_prompt, model_name)
            
            # Remove any markdown code fences that might be included in the script
            script = script.strip()
            if script.startswith("```") and "```" in script[3:]:
                # This is a markdown code block - extract just the code
                first_line_end = script.find("\n")
                script = script[first_line_end+1:]
                # Find the closing fence
                if "```" in script:
                    script = script[:script.rindex("```")]
            
            # Modify the output filename to avoid conflicts between models
            # Look for various forms of saveAs or save with output.FCStd
            script_lines = script.splitlines()
            for i, line in enumerate(script_lines):
                # Replace doc.save() with doc.saveAs() first (saveAs is required for first-time save)
                script_lines[i] = script_lines[i].replace("doc.save(", "doc.saveAs(")
                script_lines[i] = script_lines[i].replace("Doc.save(", "Doc.saveAs(")
                script_lines[i] = script_lines[i].replace("App.ActiveDocument.save(", "App.ActiveDocument.saveAs(")
                script_lines[i] = script_lines[i].replace("FreeCAD.ActiveDocument.save(", "FreeCAD.ActiveDocument.saveAs(")
                
                # Check for various ways the models might save files
                if any(pattern in line for pattern in [
                    "saveAs", "save(", "SaveAs", "Save("
                ]) and any(path in line for pattern in [
                    "/data/output.FCStd", 
                    "/data/output", 
                    "output.FCStd", 
                    '"output.FCStd"',
                    "'output.FCStd'"
                ] for path in [pattern]):
                    # Replace the filename with our model-specific filename
                    script_lines[i] = script_lines[i].replace("output.FCStd", f"output{script_file_suffix}.FCStd")
                    script_lines[i] = script_lines[i].replace('"output"', f'"output{script_file_suffix}"')
                    script_lines[i] = script_lines[i].replace("'output'", f"'output{script_file_suffix}'")
            
            script = "\n".join(script_lines)
            
            # In a headless docker environment FreeCADGui is unavailable; strip any imports that the model may have added
            if "FreeCADGui" in script:
                cleaned_lines = []
                for line in script.splitlines():
                    if "FreeCADGui" in line:
                        # Comment out the line so that line numbers stay unchanged (useful for tracebacks)
                        cleaned_lines.append(f"# [removed] {line}")
                    else:
                        cleaned_lines.append(line)
                script = "\n".join(cleaned_lines)
            
            # Execute the script
            doc_path, error_info = try_execute_freecad_script(script, script_file_suffix)
            
            # Add script to result
            model_result["script"] = script
            
            # Add FCStd file URL if available
            if doc_path:
                # Convert filesystem path to URL path
                fcstd_url = f"/output{script_file_suffix}.FCStd"
                model_result["fcstd_url"] = fcstd_url
            
            # Add error information if we have it
            stderr_output = error_info or ""
            if not doc_path:
                if stderr_output and "has no attribute" in stderr_output:
                    model_result["error"] = "The LLM generated code with an invalid FreeCAD function"
                elif stderr_output and "Exception" in stderr_output:
                    model_result["error"] = "The FreeCAD script had execution errors"
                else:
                    model_result["error"] = "FreeCAD script failed to generate a model"
                
                if error_info:
                    model_result["error_details"] = error_info
            
            # Check if we successfully created an STL file and add its URL
            stl_path = Path("static") / f"output{script_file_suffix}.stl"
            if stl_path.exists() and stl_path.stat().st_size > 0:
                stl_url = f"/output{script_file_suffix}.stl"
                model_result["stl_url"] = stl_url
                
        except Exception as e:
            # Capture any error during generation
            model_result["script"] = f"# Error: {str(e)}"
            model_result["error"] = f"Failed to generate script: {str(e)}"
        
        results.append(model_result)
    
    return jsonify({"results": results})

@app.route("/api/models", methods=["GET"])
def get_models():
    """Return the list of available models with their display names."""
    model_info = [
        {"id": model_id, "name": MODEL_DISPLAY_NAMES.get(model_id, model_id)}
        for model_id in AVAILABLE_MODELS
    ]
    return jsonify(model_info)

@app.route("/")
def serve_index():
    return send_from_directory(app.static_folder, "index.html")


if __name__ == "__main__":
    app.run(debug=True, port=8000) 